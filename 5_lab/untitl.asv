% Открываем файл для чтения
fileID = fopen('received_message.txt', 'r');


% Читаем данные из файла
decode_message = fread(fileID, '*ubit1'); % Чтение данных как битов (0 и 1)
fclose(fileID); % Закрываем файл после чтения
disp(decode_message);
% Преобразование бинарных данных в ASCII
Transform_BIN_ASCII = 0;
ASCII_decoder = [];



for i = 1:8:length(decode_message)
    Degree = 0;
    for j = 1:8
        Transform_BIN_ASCII = Transform_BIN_ASCII + decode_message(i+j-1) * 2^(Degree);
        Degree = Degree + 1;
    end
    ASCII_decoder = cat(2, ASCII_decoder, Transform_BIN_ASCII); % Исправлено: добавление в конец массива
    Transform_BIN_ASCII = 0;
    Degree = 0;
end

% Преобразование числовых значений ASCII в символы
SMS_decoder = ASCII_decoder; %char(ASCII_decoder);

% Вывод расшифрованного сообщения
disp('Расшифрованное сообщение: char - ');
disp(SMS_decoder);

SMS_decoder = sscanf(SMS_decoder, '%d');

disp('Расшифрованное сообщение: int - ');
disp(SMS_decoder);

% Предположим, что data — это массив байт, полученный из C++
data = [ ... ]; % Ваши данные, полученные через ZeroMQ или другой интерфейс

% Извлекаем порты из начала буфера
port1 = typecast(data(1:4), 'int32'); % Первые 4 байта — port1
port2 = typecast(data(5:8), 'int32'); % Следующие 4 байта — port2
port1_proxy = typecast(data(9:12), 'int32'); % Следующие 4 байта — port1_proxy
port2_proxy = typecast(data(13:16), 'int32'); % Следующие 4 байта — port2_proxy

% Остальные данные (если есть)
remaining_data = data(17:end); % Остальная часть буфера

% Вывод результатов
fprintf('port1 = %d\n', port1);
fprintf('port2 = %d\n', port2);
fprintf('port1_proxy = %d\n', port1_proxy);
fprintf('port2_proxy = %d\n', port2_proxy);
