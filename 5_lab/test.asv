% Чтение данных из файла
fileID = fopen('received_message.txt', 'r');
decode_message = fread(fileID, )'*uint8') % Чтение данных как байтов

fclose(fileID);

% Проверка порядка байтов (little-endian/big-endian)
if ~isempty(decode_message) && length(decode_message) >= 16
    % Преобразуем байты в целые числа (int32)
    %decode_message = decode_message / 1.5;

    port1 = typecast(decode_message(1:4), 'int32');
    port2 = typecast(decode_message(5:8), 'int32');
    port1_proxy = typecast(decode_message(9:12), 'int32');
    port2_proxy = typecast(decode_message(13:16), 'int32');


    %port1 = typecast(decode_message(2:5), 'int32');
    %port2 = typecast(decode_message(6:9), 'int32');
    %port1_proxy = typecast(decode_message(10:13), 'int32');
    %port2_proxy = typecast(decode_message(14:17), 'int32');

    % Если порядок байтов не совпадает, меняем его
    port1 = swapbytes(port1);
    port2 = swapbytes(port2);
    port1_proxy = swapbytes(port1_proxy);
    port2_proxy = swapbytes(port2_proxy);

    % Вывод результатов
    disp(['port1: ', num2str(port1)]);
    disp(['port2: ', num2str(port2)]);
    disp(['port1_proxy: ', num2str(port1_proxy)]);
    disp(['port2_proxy: ', num2str(port2_proxy)]);
else
    disp('Ошибка: Недостаточно данных для чтения портов.');
end